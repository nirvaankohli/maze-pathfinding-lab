<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Algorithm Results</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='index.css') }}"
    />
    <style>
      .results-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
      }
      .results-layout {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 1.5rem;
        height: calc(100vh - 200px);
      }
      .maze-section {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
      }
      .stats-section {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        padding: 1.5rem;
        overflow-y: auto;
      }
      .maze-display-full {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }
      .spacing-control {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin: 1rem 0;
      }
      .algo-stats {
        display: grid;
        gap: 0.75rem;
      }
      .stat-card {
        background: var(--glass);
        border: 1px solid var(--panel-border);
        padding: 1rem;
        border-radius: 8px;
      }
      .stat-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .stat-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem 1rem;
        font-size: 0.85rem;
      }
      .back-btn {
        background: var(--button-bg);
        border: 1px solid var(--light);
        color: var(--button-fg);
        padding: 0.5rem 1rem;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 600;
        font-family: "Courier New", Courier, monospace;
        transition: all 0.3s ease;
      }
      .back-btn:hover {
        background: var(--dark);
        color: var(--light);
        transform: scale(1.05);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="results-header">
        <div>
          <h1 id="title">Algorithm Results</h1>
          <div class="subtitle small">
            Compare pathfinding performance and visualizations
          </div>
        </div>
        <a href="/" class="back-btn">‚Üê Back to Generator</a>
      </div>

      <div class="results-layout">
        <div class="maze-section">
          <div class="spacing-control">
            <label class="small">Path Spacing:</label>
            <input
              id="spacing"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0.25"
              style="flex: 1"
            />
          </div>

          <div class="maze-display-full">
            <div id="mazeArea" class="maze-area">
              <div id="mazeContainer" class="maze-container"></div>
              <canvas
                id="mazeCanvas"
                class="maze-canvas"
                aria-hidden="true"
              ></canvas>
            </div>
          </div>

          <div class="legend" id="legend" style="margin-top: 1rem"></div>
        </div>

        <div class="stats-section">
          <h3 style="margin-top: 0">Algorithm Statistics</h3>
          <div id="algorithmStats" class="algo-stats"></div>
        </div>
      </div>
    </div>

    <script>
      const colorMap = {
        DFS: "#736ee1",
        BFS: "#2ad1d6",
        "A*": "#7efc6e",
        JPS: "#ffb86b",
        Dijkstra: "#d57ef5",
        GBFS: "#ffd56b",
      };

      let mazeData = null;
      let algoResults = null;

      function loadData() {
        const mazeStr = sessionStorage.getItem("mazeData");
        const algoStr = sessionStorage.getItem("algoResults");
        if (!mazeStr || !algoStr) {
          window.location.href = "/";
          return false;
        }
        mazeData = JSON.parse(mazeStr);
        algoResults = JSON.parse(algoStr);
        return true;
      }

      function displayMaze(mazeArray, container, start, goal) {
        const table = document.createElement("table");
        table.className = "maze-table";

        const containerWidth = Math.min(window.innerWidth - 500, 800);
        const containerHeight = Math.min(window.innerHeight - 200, 800);

        // Calculate cell size to maintain 1:1 aspect ratio and fit both dimensions
        const cellSizeByWidth = Math.floor(
          containerWidth / mazeArray[0].length
        );
        const cellSizeByHeight = Math.floor(containerHeight / mazeArray.length);
        const cellSize = Math.max(
          4,
          Math.min(cellSizeByWidth, cellSizeByHeight)
        );

        for (let r = 0; r < mazeArray.length; r++) {
          const tr = document.createElement("tr");
          for (let c = 0; c < mazeArray[r].length; c++) {
            const td = document.createElement("td");
            td.style.width = cellSize + "px";
            td.style.height = cellSize + "px";
            td.style.minWidth = cellSize + "px";
            td.style.minHeight = cellSize + "px";
            td.className = mazeArray[r][c] === 1 ? "cell-wall" : "cell-path";
            if (start && start[0] === r && start[1] === c)
              td.classList.add("cell-start");
            if (goal && goal[0] === r && goal[1] === c)
              td.classList.add("cell-goal");
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }

        container.innerHTML = "";
        container.appendChild(table);

        const canvas = document.getElementById("mazeCanvas");
        const rect = table.getBoundingClientRect();
        const dpi = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.floor(rect.width * dpi));
        canvas.height = Math.max(1, Math.floor(rect.height * dpi));
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
        canvas.style.left = table.offsetLeft + "px";
        canvas.style.top = table.offsetTop + "px";

        window.mazeRender = {
          mazeArray,
          cellSize,
          width: rect.width,
          height: rect.height,
          start,
          goal,
        };
      }

      function computeOffsetPoint(prev, cur, next, offsetPx) {
        let tx = 0,
          ty = 0;
        if (prev && next) {
          tx = next[0] - prev[0];
          ty = next[1] - prev[1];
        } else if (next) {
          tx = next[0] - cur[0];
          ty = next[1] - cur[1];
        } else if (prev) {
          tx = cur[0] - prev[0];
          ty = cur[1] - prev[1];
        }
        const len = Math.hypot(tx, ty) || 1;
        tx /= len;
        ty /= len;
        const nx = -ty,
          ny = tx;
        return [cur[0] + nx * offsetPx, cur[1] + ny * offsetPx];
      }

      function drawPaths() {
        const render = window.mazeRender;
        const canvas = document.getElementById("mazeCanvas");
        if (!render || !canvas) return;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        const dpi = window.devicePixelRatio || 1;
        ctx.setTransform(dpi, 0, 0, dpi, 0, 0);
        ctx.clearRect(0, 0, render.width, render.height);

        const cellSize = render.cellSize;
        const legendChecks = document.querySelectorAll(
          '.legend input[type="checkbox"]'
        );
        const enabled = {};
        legendChecks.forEach((cb) => {
          enabled[cb.dataset.alg] = cb.checked;
        });

        const selected = Object.keys(algoResults).filter(
          (alg) => enabled[alg] && !algoResults[alg].error
        );
        if (selected.length === 0) return;

        const spacingFactor = parseFloat(
          document.getElementById("spacing").value
        );
        const spacingPx = Math.max(1, cellSize * spacingFactor);
        const n = selected.length;
        const baseLine = Math.max(2, Math.floor(cellSize * 0.2));

        for (let idx = 0; idx < selected.length; idx++) {
          const alg = selected[idx];
          const res = algoResults[alg];
          const path = res.outcome?.path || [];
          if (!path || path.length < 2) continue;

          const offsetIndex = idx - (n - 1) / 2;
          const offsetPx = offsetIndex * spacingPx;

          ctx.lineWidth = baseLine;
          ctx.strokeStyle = colorMap[alg] || "#fff";
          ctx.globalAlpha = 0.9;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";

          const pts = path.map(([r, c]) => [
            c * cellSize + cellSize / 2,
            r * cellSize + cellSize / 2,
          ]);
          const offsetPts = pts.map((p, i) =>
            computeOffsetPoint(pts[i - 1], pts[i], pts[i + 1], offsetPx)
          );

          ctx.beginPath();
          for (let i = 0; i < offsetPts.length; i++) {
            const [x, y] = offsetPts[i];
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();

          const start = offsetPts[0];
          const end = offsetPts[offsetPts.length - 1];
          ctx.fillStyle = colorMap[alg] || "#fff";
          ctx.globalAlpha = 0.95;
          ctx.beginPath();
          ctx.arc(
            start[0],
            start[1],
            Math.max(3, Math.floor(cellSize * 0.3)),
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.beginPath();
          ctx.arc(
            end[0],
            end[1],
            Math.max(3, Math.floor(cellSize * 0.3)),
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      }

      function createLegend() {
        const legend = document.getElementById("legend");
        legend.innerHTML = "";

        for (const alg of Object.keys(algoResults)) {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.style.padding = "6px 12px";

          const dot = document.createElement("span");
          dot.className = "color-dot";
          dot.style.background = colorMap[alg] || "#fff";

          const label = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = true;
          cb.dataset.alg = alg;
          cb.addEventListener("change", drawPaths);

          label.appendChild(cb);
          label.appendChild(document.createTextNode(" " + alg));
          chip.appendChild(dot);
          chip.appendChild(label);
          legend.appendChild(chip);
        }
      }

      function createStats() {
        const container = document.getElementById("algorithmStats");
        container.innerHTML = "";

        for (const [alg, res] of Object.entries(algoResults)) {
          const card = document.createElement("div");
          card.className = "stat-card";

          if (res.error) {
            card.innerHTML = `
                        <div class="stat-header">
                            <span class="color-dot" style="background:${
                              colorMap[alg] || "#fff"
                            }"></span>
                            <strong>${alg}</strong>
                        </div>
                        <div style="color:var(--danger);font-size:0.85rem">${
                          res.error
                        }</div>
                    `;
          } else {
            const outcome = res.outcome || {};
            const effort = res.effort || {};
            const pq = res.path_quality || {};
            const cov = res.coverage || {};

            card.innerHTML = `
                        <div class="stat-header">
                            <span class="color-dot" style="background:${
                              colorMap[alg] || "#fff"
                            }"></span>
                            <strong>${alg}</strong>
                        </div>
                        <div class="stat-grid">
                            <div><strong>Success:</strong></div><div>${
                              outcome.success || "false"
                            }</div>
                            <div><strong>Path Length:</strong></div><div>${
                              outcome.path_length || "-"
                            }</div>
                            <div><strong>Time:</strong></div><div>${(
                              effort.time_ms || 0
                            ).toFixed(2)}ms</div>
                            <div><strong>Visited:</strong></div><div>${
                              effort.visited_count || "-"
                            }</div>
                            <div><strong>Opt. Gap:</strong></div><div>${
                              pq.optimality_gap != null
                                ? pq.optimality_gap.toFixed(2)
                                : "-"
                            }</div>
                            <div><strong>Exploration:</strong></div><div>${(
                              cov.exploration_ratio || 0
                            ).toFixed(3)}</div>
                        </div>
                    `;
          }
          container.appendChild(card);
        }
      }

      function init() {
        if (!loadData()) return;

        const mazeArray = mazeData.maze || mazeData.grid || mazeData;
        const start = mazeData.start || mazeData.start_pos;
        const goal = mazeData.goal || mazeData.goal_pos;

        displayMaze(
          mazeArray,
          document.getElementById("mazeContainer"),
          start,
          goal
        );
        createLegend();
        createStats();
        drawPaths();

        document.getElementById("spacing").addEventListener("input", drawPaths);
      }

      init();
    </script>
  </body>
</html>
