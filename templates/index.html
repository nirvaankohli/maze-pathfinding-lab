<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Solver Comparison</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='index.css') }}"
    />
  </head>
  <body>
    <div class="app">
      <div class="header">
        <div class="logo">MS</div>
        <div>
          <h1 id="title">Maze Solver Comparison</h1>
          <div class="subtitle small">
            Compare pathfinding algorithms on randomized mazes — tuned for
            difficulty
          </div>
        </div>
      </div>

      <aside class="panel">
        <div class="controls">
          <div class="row">
            <div class="label">Algorithms</div>
            <div
              id="algorithm-select"
              class="multiselect"
              aria-haspopup="listbox"
            >
              <div
                class="ms-control"
                tabindex="0"
                role="button"
                aria-expanded="false"
              >
                <div class="ms-chips" aria-live="polite"></div>
                <div class="ms-caret">▾</div>
              </div>
              <div class="ms-dropdown" role="listbox">
                <div class="ms-optgroup">
                  <label class="ms-option"
                    ><input
                      type="checkbox"
                      name="algorithm"
                      value="DFS"
                      checked
                    />
                    <span>DFS</span></label
                  >
                  <label class="ms-option"
                    ><input type="checkbox" name="algorithm" value="BFS" />
                    <span>BFS</span></label
                  >
                  <label class="ms-option"
                    ><input type="checkbox" name="algorithm" value="A*" />
                    <span>A*</span></label
                  >
                  <label class="ms-option"
                    ><input type="checkbox" name="algorithm" value="JPS" />
                    <span>JPS</span></label
                  >
                  <label class="ms-option"
                    ><input type="checkbox" name="algorithm" value="Dijkstra" />
                    <span>Dijkstra</span></label
                  >

                  <label class="ms-option"
                    ><input type="checkbox" name="algorithm" value="GBFS" />
                    <span>GBFS</span></label
                  >
                </div>
              </div>
              <small
                class="small"
                style="margin-top: 0.25rem; color: var(--muted)"
                >Select one or more</small
              >
            </div>
          </div>

          <div class="row">
            <div class="label">Rows</div>
            <input id="rows" type="number" min="5" step="2" value="21" />
          </div>

          <div class="row">
            <div class="label">Cols</div>
            <input id="cols" type="number" min="5" step="2" value="21" />
          </div>

          <div class="row">
            <div class="label">Method</div>
            <select id="method">
              <option value="dfs">DFS</option>
              <option value="prim">Prim</option>
            </select>
          </div>

          <div class="row">
            <div class="label">Seed</div>
            <input id="seed" type="text" placeholder="random" />
          </div>

          <div class="row">
            <div class="label">Braiding</div>
            <input
              id="braid"
              type="range"
              min="0"
              max="1"
              step="0.05"
              value="0.2"
            />
          </div>

          <div class="row">
            <button id="generate" onclick="generateMaze()">
              Generate Maze
            </button>
          </div>
          <div class="row">
            <button id="run-algos" onclick="runAlgorithms()" disabled>
              Run Algorithms
            </button>
          </div>
        </div>
      </aside>

      <main class="main">
        <section class="panel maze-wrap">
          <div class="maze-display">
            <div id="mazeArea" class="maze-area">
              <div id="mazeContainer" class="maze-container"></div>
              <canvas
                id="mazeCanvas"
                class="maze-canvas"
                aria-hidden="true"
              ></canvas>
            </div>
            <pre id="maze" class="maze-pre" style="display: none">
              (Generate a maze to preview here)
            </pre>
          </div>
          <div class="metrics" id="metrics">
            <div class="metric">Start: <span id="start">-</span></div>
            <div class="metric">Goal: <span id="goal">-</span></div>
            <div class="metric">
              Path length: <span id="path_length">-</span>
            </div>
            <div class="metric">Dead ends: <span id="dead_ends">-</span></div>
            <div class="metric">Junctions: <span id="junctions">-</span></div>
          </div>
        </section>
      </main>
    </div>

    <script>
      const root = document.getElementById("algorithm-select");
      const control = root.querySelector(".ms-control");
      const dropdown = root.querySelector(".ms-dropdown");
      const chips = root.querySelector(".ms-chips");
      const inputs = Array.from(
        root.querySelectorAll('input[name="algorithm"]')
      );

      function renderChips() {
        chips.innerHTML = "";
        const selected = inputs.filter((i) => i.checked).map((i) => i.value);
        if (selected.length === 0) {
          chips.textContent = "None selected";
          chips.classList.add("ms-placeholder");
          return;
        }
        chips.classList.remove("ms-placeholder");
        selected.forEach((val) => {
          const el = document.createElement("span");
          el.className = "ms-chip";
          el.textContent = val;
          el.tabIndex = 0;
          el.setAttribute("data-value", val);

          el.addEventListener("click", () => {
            const input = inputs.find((i) => i.value === val);
            if (input) {
              input.checked = false;
              renderChips();
            }
          });
          chips.appendChild(el);
        });
      }

      function drawPaths(results) {
        // parallel-offset drawing: draw multiple algorithms side-by-side with reduced thickness
        const render = window.mazeRender;
        const canvas = document.getElementById("mazeCanvas");
        if (!render || !canvas) return;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        const dpi = window.devicePixelRatio || 1;
        ctx.setTransform(dpi, 0, 0, dpi, 0, 0);
        ctx.clearRect(0, 0, render.width, render.height);

        const cellSize = render.cellSize;
        const colorMap = {
          DFS: "#736ee1",
          BFS: "#2ad1d6",
          "A*": "#7efc6e",
          JPS: "#ffb86b",
          Dijkstra: "#d57ef5",
          GBFS: "#ffd56b",
        };

        // legend checkboxes determine which algs to draw
        const legendChecks = document.querySelectorAll(
          '.legend input[type="checkbox"]'
        );
        const enabled = {};
        legendChecks.forEach((cb) => {
          enabled[cb.dataset.alg] = cb.checked;
        });

        // collect selected algorithms in deterministic order
        const selected = Object.keys(results).filter(
          (alg) => enabled[alg] && !results[alg].error
        );
        if (selected.length === 0) return;

        const spacingFactor = parseFloat(
          document.getElementById("spacing")?.value || 0.25
        );
        const spacingPx = Math.max(1, cellSize * spacingFactor);
        const n = selected.length;

        // small helper to compute normal-offset point
        function computeOffsetPoint(prev, cur, next, offsetPx) {
          let tx = 0,
            ty = 0;
          if (prev && next) {
            tx = next[0] - prev[0];
            ty = next[1] - prev[1];
          } else if (next) {
            tx = next[0] - cur[0];
            ty = next[1] - cur[1];
          } else if (prev) {
            tx = cur[0] - prev[0];
            ty = cur[1] - prev[1];
          }
          const len = Math.hypot(tx, ty) || 1;
          tx /= len;
          ty /= len;
          const nx = -ty,
            ny = tx; // left normal
          return [cur[0] + nx * offsetPx, cur[1] + ny * offsetPx];
        }

        // thinner stroke relative to cell size
        const baseLine = Math.max(1, Math.floor(cellSize * 0.18));

        for (let idx = 0; idx < selected.length; idx++) {
          const alg = selected[idx];
          const res = results[alg];
          const path = res.outcome?.path || [];
          if (!path || path.length < 2) continue;

          const offsetIndex = idx - (n - 1) / 2; // center algorithms around zero
          const offsetPx = offsetIndex * spacingPx;

          ctx.lineWidth = baseLine;
          ctx.strokeStyle = colorMap[alg] || "#fff";
          ctx.globalAlpha = 0.95;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";

          // build canvas points (x,y)
          const pts = path.map(([r, c]) => [
            c * cellSize + cellSize / 2,
            r * cellSize + cellSize / 2,
          ]);
          const offsetPts = pts.map((p, i) =>
            computeOffsetPoint(pts[i - 1], pts[i], pts[i + 1], offsetPx)
          );

          ctx.beginPath();
          for (let i = 0; i < offsetPts.length; i++) {
            const [x, y] = offsetPts[i];
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();

          // endpoints (small)
          const start = offsetPts[0];
          const end = offsetPts[offsetPts.length - 1];
          ctx.fillStyle = colorMap[alg] || "#fff";
          ctx.globalAlpha = 0.95;
          ctx.beginPath();
          ctx.arc(
            start[0],
            start[1],
            Math.max(2, Math.floor(cellSize * 0.25)),
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.beginPath();
          ctx.arc(
            end[0],
            end[1],
            Math.max(2, Math.floor(cellSize * 0.25)),
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
        // keep last results so spacing or toggles can redraw
        window.lastResults = results;
      }

      async function generateMaze() {
        const rowsEl = document.getElementById("rows");
        const colsEl = document.getElementById("cols");
        const methodEl = document.getElementById("method");
        const seedEl = document.getElementById("seed");
        const braidEl = document.getElementById("braid");
        const container = document.getElementById("mazeContainer");
        const display = document.getElementById("maze");
        const button = document.getElementById("generate");
        button.disabled = true;
        button.textContent = "Generating Maze...";
        display.style.display = "block";
        display.textContent = "Be patient... Maze is generating...";

        try {
          const algs = inputs
            .filter((i) => i.checked)
            .map((i) => i.value)
            .join(",");
          const params = new URLSearchParams();
          params.set("rows", rowsEl.value);
          params.set("cols", colsEl.value);
          params.set("method", methodEl.value);
          if (seedEl.value && seedEl.value.trim() !== "")
            params.set("seed", seedEl.value.trim());
          params.set("braiding", braidEl.value);
          if (algs) params.set("algorithms", algs);

          const response = await fetch(`/maze/generate?${params.toString()}`);
          // try parse JSON response
          let obj;
          try {
            obj = await response.json();
          } catch (e) {
            const text = await response.text();
            obj = JSON.parse(text);
          }

          // extract maze and metadata (be permissive to several key names)
          const mazeArray = obj.maze || obj.grid || obj;
          const start = obj.start || obj.start_pos || obj.startPos || null;
          const goal = obj.goal || obj.goal_pos || obj.goalPos || null;
          const metrics = obj.metrics || {
            dead_ends: obj.dead_ends || obj.deadEnds || "-",
            junctions: obj.junctions || obj.junctions || "-",
          };

          // fill stats
          const startEl = document.getElementById("start");
          const goalEl = document.getElementById("goal");
          const deadEl = document.getElementById("dead_ends");
          const junEl = document.getElementById("junctions");
          startEl.textContent = start
            ? Array.isArray(start)
              ? `${start[0]}, ${start[1]}`
              : JSON.stringify(start)
            : "-";
          goalEl.textContent = goal
            ? Array.isArray(goal)
              ? `${goal[0]}, ${goal[1]}`
              : JSON.stringify(goal)
            : "-";
          deadEl.textContent = metrics.dead_ends ?? metrics.deadEnds ?? "-";
          junEl.textContent = metrics.junctions ?? metrics.junctions ?? "-";
          const pathEl = document.getElementById("path_length");
          pathEl.textContent = metrics.path_length ?? metrics.pathLength ?? "-";

          display.style.display = "none";
          displayMaze(
            mazeArray,
            container,
            parseInt(colsEl.value),
            start,
            goal
          );
          window.lastMazeObj = obj;
          document.getElementById("run-algos").disabled = false;
          button.disabled = false;
          button.textContent = "Generate Maze";
        } catch (error) {
          console.log("Error fetching/processing response: ", error);
          button.disabled = false;
          button.textContent = "Generate Maze";
        }
      }

      function displayMaze(mazeArray, container, amount, start, goal) {
        const table = document.createElement("table");
        table.className = "maze-table";
        table.style.borderCollapse = "collapse";

        const containerWidth =
          container.clientWidth ||
          Math.max(
            200,
            parseInt(window.getComputedStyle(container).width) || 400
          );
        const containerHeight = container.clientHeight || containerWidth;

        // Calculate cell size to maintain 1:1 aspect ratio and fit both dimensions
        const cellSizeByWidth = Math.floor(containerWidth / amount);
        const cellSizeByHeight = Math.floor(containerHeight / mazeArray.length);
        const cellSize = Math.max(
          4,
          Math.min(cellSizeByWidth, cellSizeByHeight)
        );

        for (let r = 0; r < mazeArray.length; r++) {
          const row = mazeArray[r];
          const tr = document.createElement("tr");
          for (let c = 0; c < row.length; c++) {
            const cell = row[c];
            const td = document.createElement("td");
            td.style.width = cellSize + "px";
            td.style.height = cellSize + "px";
            td.style.minWidth = cellSize + "px";
            td.style.minHeight = cellSize + "px";
            td.className = cell === 1 ? "cell-wall" : "cell-path";

            if (
              start &&
              Array.isArray(start) &&
              start[0] === r &&
              start[1] === c
            ) {
              td.classList.add("cell-start");
            }
            if (goal && Array.isArray(goal) && goal[0] === r && goal[1] === c) {
              td.classList.add("cell-goal");
            }

            tr.appendChild(td);
          }
          table.appendChild(tr);
        }

        container.innerHTML = "";
        container.appendChild(table);

        // prepare canvas overlay sizing and store render info
        const area = document.getElementById("mazeArea");
        const canvas = document.getElementById("mazeCanvas");
        const rect = table.getBoundingClientRect();
        const dpi = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.floor(rect.width * dpi));
        canvas.height = Math.max(1, Math.floor(rect.height * dpi));
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
        canvas.style.left = table.offsetLeft + "px";
        canvas.style.top = table.offsetTop + "px";
        const ctx = canvas.getContext("2d");
        if (ctx) {
          ctx.setTransform(dpi, 0, 0, dpi, 0, 0);
          ctx.clearRect(0, 0, rect.width, rect.height);
        }
        window.mazeRender = {
          mazeArray,
          cellSize,
          width: rect.width,
          height: rect.height,
          start,
          goal,
        };
      }

      async function runAlgorithms() {
        if (!window.lastMazeObj) return;
        const algs = inputs.filter((i) => i.checked).map((i) => i.value);
        const payload = {
          maze:
            window.lastMazeObj.maze ||
            window.lastMazeObj.grid ||
            window.lastMazeObj,
          start: window.lastMazeObj.start || window.lastMazeObj.start_pos,
          goal: window.lastMazeObj.goal || window.lastMazeObj.goal_pos,
          algorithms: algs,
        };

        const runBtn = document.getElementById("run-algos");
        runBtn.disabled = true;
        runBtn.textContent = "Running...";
        try {
          const resp = await fetch("/maze/solve", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await resp.json();

          sessionStorage.setItem(
            "mazeData",
            JSON.stringify(window.lastMazeObj)
          );
          sessionStorage.setItem(
            "algoResults",
            JSON.stringify(data.results || {})
          );
          window.location.href = "/results";
        } catch (e) {
          console.error("Error running algorithms", e);
          alert("Error running algorithms: " + e.message);
        }
        runBtn.disabled = false;
        runBtn.textContent = "Run Algorithms";
      }

      function escapeHtml(s) {
        return s.replace(/[&<>]/g, function (c) {
          return { "&": "&amp;", "<": "&lt;", ">": "&gt;" }[c];
        });
      }

      function toggle(open) {
        const isOpen = root.classList.contains("ms-open");
        const want = open === undefined ? !isOpen : !!open;
        root.classList.toggle("ms-open", want);
        control.setAttribute("aria-expanded", want ? "true" : "false");
      }

      control.addEventListener("click", () => toggle());
      control.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          toggle();
        }
      });

      inputs.forEach((i) => {
        i.addEventListener("change", () => renderChips());
      });

      // redraw when spacing changes
      const spacingEl = document.getElementById("spacing");
      if (spacingEl)
        spacingEl.addEventListener("input", () => {
          if (window.lastResults) drawPaths(window.lastResults);
        });

      document.addEventListener("click", (e) => {
        if (!root.contains(e.target)) toggle(false);
      });

      renderChips();
    </script>
  </body>
</html>
